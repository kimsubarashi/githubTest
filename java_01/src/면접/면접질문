1. 상수
/*
 * 상수 : 프로그램이 실행되는 동안, 값이 변하지 않는 수 또는 변경 불가능한 수
 *       주로 대문자 사용(변수는 소문자)
 *       만약 값을 변경해야 할 경우, 상수를 선언한 곳의 값만 변경하면 된다.
 *       
 * 문법 : final 자료형 변수명;  예) final PI = 3.14;
 *     1) 변수(상수) : 변수에 값 변경불가
 *     2) 메서드 : 재정의 불가
 *     3) 클래스 : 상속 불가     
 */
 
 -----------------------------------------
 2. 구구단 출력(ch02._16_ForEx)
 /* 
 * Test4. for문으로 구구단 작성
 * 2~9단까지 출력
 * 
 * *** 구구단 출력 ***
 * === 2단 ===
 * 2 * 1 = 2
 * ...
 * 2 * 9 = 18
 * === 9단 ===
 * 9 * 1 = 9
 * ...
 * 9 * 9 = 81
 * ==========  마지막에 한번만
 */ 
  -----------------------------------------
  
3. [ 오버로드 vs 오버라이딩 ]  
생성자 오버로드 => 메서드나 생성자의 매개변수 갯수가 다르거나, 매개변수 타입이 다른 경우를 말하며,리턴타입은 무관한다.
cf) 오버라이드(상속 : 부모의 메서드를 재정의)

-------------------------------------------

4. 접근제어자 큰순서
private(같은 클래스) < default(같은 패키지) < protected(같은 패키지 + 상속관계클래스) < public(외부클래스 어디서나)

-------------------------------------------
5. static
   // p184
   /*
    * static 변수 = 클래스 변수 = 공유변수
    * - 프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 데이터영역 메모리 공간에 할당된다.
    * 객체를 생성하지 않고, 바로 클래스명으로 접근가능하다.
    * 인스턴스마다 생성되는 변수가 아니라 클래스에 속해 한번만 생성되는 변수이고,
    * 여러 인스턴스가 공유한다.
    * 인스턴스가 생성되지 않아도 사용할 수 있기 때문에 클래스명.static 변수, 클래스명.static 메서드 사용가능
    * - static 변수나 메서드는 static 메서드에서 호출가능
    *   static 메서드에서 인스턴스 변수나 메서드를 호출시 컴파일 오규가 난다.
    *   static 메서드는 프로그램 실행시 자동으로 메모리에 올라가나, 일반메서드는 객체를 생성해야 메모리에 올라간다. 
    */
-----------------------------------------------
싱글톤, 배열

-----------------------------------------------
/*
* [면접]
* 상속 : 자식클래스 extends 부모클래스 { .... }
* - extends : 확장하다의 의미
* - 공통으로 사용하는 멤버변수와 멤버메서드를 부모클래스에서 정의한다.
* - 부모클래스는 일반적이고 공통적이며, 자식클래스는 구체적이고 유일하다.
* 
* - 사용이유 : 부모클래스의 멤버변수와 멤버메서드를 재사용.
*          중복되는 코드를 줄임으로써 손쉽게 개발, 유지보수 가능
* - 부모클래스의 멤버를 private으로 선언한 경우, 자식클래스에서 접근할 수 없다.
*   접근제어자 protected의 경우 자식클래스에서 접근 가능
*/
------------------------------------------------
// printInfo에서 vip 정보 출력
   // 오버라이드 => 부모의 메서드를 재정의하며, 자식의 메서드가 실행된다.(전제조건 : 상속)
   // 부모메서드의 반환형, 메서드명, 매개변수 갯수와 자료형이 자식메서드와 모두 같아야 한다.
   
   /* p250 [면접] 오버로드 vs 오버라이드
    * @Override 어노테이션 : "이 메서드는 재정의된 메서드입니다." 라고 컴파일러에게 명확히 알려주는 역할을 한다.
    * 오버라이딩(=재정의)
    * - 자식클래스의 메서드가 부모클래스의 메서드를 오버라이드(재정의)한다라고 말한다.
    * - 상속에서 부모클래스의 메서드를 변경하고자 할 때 사용한다.
    * - 메서드명, 매개변수, 매개변수 자료형, 반환형까지 모두 동일해야 한다.
    *    (동일하지 않으면 컴파일러가 다른 메서드로 인식한다.)
    * - 호출시 오버라이딩된 자식메서드가 호출된다.
    *    (오버라이드 목적 : 부모클래스의 메서드를 변경해서 자식쪽에서 호출하고자 하는 의도)   
    */
    
   /*
   * 추상이란?
   * - 여러가지 사물이나 개념으로부터 공통이 되는 특성을 파악하는 것을 말한다.
   * 
   * [면접]
   * 1. 추상클래스 => 업무표준화, 작업명세서 : 정의된 추상메서드
   * - 하나 이상의 추상메서드를 가지고 있는 클래스를 의미한다.
   * - abstract 키워드를 이용하여 구현되지 않는 추상메서드를 기술할 수 있다.
   * - 자식클래스에게 구현을 위임하고자 할 때 사용되며, 프로그램의 확장성을 취해 많이 사용하는 설계방법이다.
   * - 추상클래스는 일반메서드, 추상메서드 모두 올 수 있다.
   * - 전제조건은 반드시 상속을 해야 한다.
   * - 다형성 적용 가능하다.
   * 
   * - 문법 : public abstract class 클래스명 {
   *             public abstract 반환형 메서드명();  // 추상메서드
   *       }
   * 
   * 2. 추상메서드
   * - 하위클래스가 어떤 클래스냐에 따라 구현코드가 달라지며, 하위클래스에 구현을 위임하는 것이다.
   * - 미완성되어있는 메서드이며, 몸체가 없는 메서드로서 항상 세미콜론(;)으로 종료되어야 한다.
   * 
   *  3. 추상클래스의 상속
   *  - 추상클래스를 상속받은 자식클래스는 추상메서드를 반드시 재정의(Override) 해야 하며,
   *    재정의하지 않으면 컴파일 오류가 발생한다.
   *  - 자식클래스에게 강제성과 통일성을 줄 수 있다.(협업시 작업명세서)  
   *       
   * 4. 추상클래스의 객체 생성
   * - 추상클래스는 객체를 생성할 수 없으며(추상 메서드 때문), 상속 계층에서
   *   추상적인 개념을 나타내기 위한 용도로 사용한다.
   * - 상속을 통하여 자식클래스에서 추상메서드를 구현하고, 자식클래스 객체를 생성하여 메서드를 접근할 수 있다.  
   * 
   */
   /*  p406 p439
       * 해싱(hashing) : 키를 이용해서 해시테이블로부터 데이터를 가져오는 과정
       * 
       * [면접] p439
       * HashMap
       * 1) 특징
       * - 데이터의 순서를 보장하지 않는다.
       * - key와 value 쌍으로 저장한다.
       * - key는 중복되면 안된다. 값은 중복되도 무관하다.
       * - key를 이용해서 value를 가져올 수 있다.
       * - List 계열과 달리 index가 없다.
       * - Map이라는 인터페이를 구현한 클래스이다.
       * 
       * 2) 선언
       * - HashMap<Key 클래스타입, value 클래스타입> map = new HashMap<Key 클래스타입, value 클래스타입>();
       * - Map<Key 클래스타입, value 클래스타입> map = new HashMap<Key 클래스타입, value 클래스타입>(); // 다형성 적용
       * 
       * 3) 메서드
       * - 데이터 추가 : put(key, value);
       * - 데이터 가져오기 : get(key)
       * - 데이터 삭제 : remove(key)
       * - 데이터가 비어있는지 여부 : isEmpty()
       * - 해당 키가 있는지 여부 : containsKey(key)
       * - 해당 값이 있는지 여부 : containsValue(value)
       * - 해당 갯수 : size()
       */
   /*
       * [면접]
       * 예외 처리 목적 : 정상종료
       * 
       * try {
       *      // 예외가 발생할 수 있는 코드 부분
       * } catch(처리할 예외타입 e) {
       *    // try 블록안에서 예외가 발생했을 때 예외를 처리하는 부분
       * } finally {
       *      // 항상 수행되는 부분(예외가 발생하지 않더라도) 
       *    // 주로 자원해제를 위한 close() 문장이 온다.
       * }
       * 1. 강제예외발생 : throw new Exception(message);
       * 2. 상위 메서드에게 예외 던지기
       *    throws Exception
       * 3. 예외 처리
       *    catch(던진 Exception e){e.getMaessage()}로 받는다.
       * 
       * catch문이 여러개일때(다중 catch) 부모 Exception이 제일 아래오도록 한다. 실행순서는 위에서부터 실행
       */